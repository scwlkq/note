# JUC

## 1）线程的基本认识

### 基本介绍

![image-20220913220933393](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220913220933393.png)

CPU切换很快，所以用户不会察觉到

为什么会有线程？

![image-20220914204356668](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220914204356668.png)

### 线程的应用场景

![image-20220914204700691](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220914204700691.png)

![image-20220914205858784](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220914205858784.png)



### 如何在Java中应用多线程

![image-20220915153351430](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915153351430.png)

![image-20220915153459437](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915153459437.png)



![image-20220915153541456](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915153541456.png)

Callable需要用线程池运行

Callable有**返回值**

![image-20220915155526172](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915155526172.png)

![image-20220915155544025](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915155544025.png)

### 线程的生命周期

![image-20220915160043349](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915160043349.png)

![image-20220915160249695](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915160249695.png)

**线程需要命名**方便找错误

定义两个线程

![image-20220920140642262](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920140642262.png)

![image-20220920141117981](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920141117981.png)

定义一个阻塞方法

![image-20220920141326311](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920141326311.png)

然后调用

![image-20220920141435630](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920141435630.png)

`jps`然后`jstake`对应的进程编号就可以看到线程的日志

## 2）线程的基本操作及原理

### Thread.join的使用及原理

![image-20220920142729231](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920142729231.png)

因为线程的执行顺序不可见，1就是`t2`先执行了

解决方法：

![image-20220920142921290](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920142921290.png)

实现原理：

![image-20220920143048265](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920143048265.png)

![image-20220920143207656](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920143207656.png)

这个是在`JVM`里面实现的，涉及到线程的销毁

`JVM`的源码：

![image-20220920143358480](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920143358480.png)

**Thread.join的作用就是保证线程执行结果的可见性**

基于notify和wait实现的

### Thread.sleep的作用

使线程暂停执行一段时间，直到等待的时间结束才恢复执行**或在这段时间内被中断**

工作流程：

![image-20220920144125284](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920144125284.png)

算法：

![image-20220920144504147](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920144504147.png)

 

> 问题

![image-20220920144210633](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920144210633.png)

1. ![image-20220920144706602](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920144706602.png)

sleep(1000)是告诉线程，未来`1000ms`内我不会去抢占CPU，但是`1000ms`结束的时候，不一定CPU立马有空，可能别的线程在执行，等执行完了（执行完了也可能去执行其他线程）才会来执行这个睡了`1000ms`下面的程序

2. sleep（0）出让CPU，触发OS进行一次CPU的竞争，根据优先级分配CPU

###  wait和notify的使用

如何实现，一个线程修改了值，另一个线程感知到了这个改变然后启动?



这里借助生产者消费者模型

生产者：

```java
package waitandnotify;

import java.util.Queue;

/**
 * @Author: sc
 * @Date: 2022/9/20 15:29
 */
public class Producer implements Runnable{

    private Queue<String> bags;
    private int size;

    public Producer(Queue<String> bags, int size) {
        this.bags = bags;
        this.size = size;
    }

    @Override
    public void run() {
        int i=0;
        while(true){
            i++;
            synchronized (bags){
                while(bags.size() == size){
                    System.out.println("bags已经满了！");
                    try {
                        bags.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try{
                    Thread.sleep(1000);

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("生产者生产了：bag"+i);
                bags.add("bags"+i);
                // 唤醒处于阻塞状态下的消费者
                bags.notifyAll();
            }
        }
    }
}
```

consumer:

```java
package waitandnotify;

import java.util.Queue;

/**
 * @Author: sc
 * @Date: 2022/9/20 15:29
 */
public class Consumer implements Runnable{

    private Queue<String> bags;
    private int size;

    public Consumer(Queue<String> bags, int size) {
        this.bags = bags;
        this.size = size;
    }

    @Override
    public void run() {
        while(true){
            synchronized (bags) {
                while(bags.isEmpty()){
                    System.out.println("bags为空");
                }
                try {
                    bags.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 消费
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                String bag = bags.remove();
                System.out.println("消费者消费了:"+bag);
                // 唤醒生产者
                bags.notifyAll();
            }
        }
    }
}

```

Application:

```java
package waitandnotify;

import java.util.LinkedList;
import java.util.Queue;

/**
 * @Author: sc
 * @Date: 2022/9/20 15:29
 */
public class App {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        int size =10;
        Producer producer = new Producer(queue,size);
        Consumer consumer = new Consumer(queue,size);
        Thread t1 = new Thread(producer);
        Thread t2 = new Thread(consumer);
        t1.start();
        t2.start();
    }

}

```

这两个线程相互通知

![image-20220920154954185](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920154954185.png)

根据业务切换线程

注意synchronized，锁住了bags，

本案例中，wait和notify是基于synchronized通信的，**两者必须在同一管道，同一个锁的范围**

synchronized实现原理暂时不深究

### Thread.interrupted和Thread.interrupt

如何正确终止一个线程？

回答`Thread.stop`就直接回家吧（qwq）

![image-20220920155407872](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920155407872.png)

**究极目的是将run方法执行结束**



可以基于共享变量的方法，终止线程

（volatile下面会有）

![](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920155653789.png)

t1.stop()相当于从操作系统的层面上掐断进程（kill -9）

`interrupt`

![image-20220920160139147](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920160139147.png)

死循环在业务中并不常见

另一种使用场景是将阻塞的线程给唤醒，如sleep，join，wait

![image-20220920160522208](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920160522208.png)

![image-20220920160634335](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920160634335.png)



`interrupted`

对设置中断标识的线程**复位**，并且返回当前的中断状态

![image-20220920161726636](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920161726636.png)

## 3）线程的安全性分析

### 原子性、可见性、有序性

今年来硬件上的优化，如缓存

![image-20220920183652266](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920183652266.png)

硬件上的一些优化会导致这些问题

不可见性

![image-20220920184315745](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220920184315745.png)

 原子性

![image-20220921184217510](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220921184217510.png)

有序性

![image-20220925103627892](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925103627892.png)

### Java内存模型

Java内存模型是一种抽象结构，他提供了合理的禁用缓存一级禁止重排序的方法来解决可见性、有序性问题

![image-20220925104220305](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925104220305.png)

![image-20220925104242558](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925104242558.png)

**提供了合理的禁用缓存一级禁止重排序的方法来解决可见性、有序性问题**

![image-20220925110711986](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925110711986.png)

### 同步关键字synchronized

可以解决可见性、原子性、有序性

可以加在代码块上，也可以加在方法上

![image-20220925111314477](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925111314477.png)

![image-20220925111406720](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925111406720.png)

锁实例对象

![image-20220925112124846](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925112124846.png)

![image-20220925112942257](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925112942257.png)

第二个框里的锁的范围可以控制



synchronized的本质

![image-20220925131115333](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925131115333.png)

synchronized

![image-20220925131644231](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925131644231.png)

### volatile关键词分析

作用：

上面讲到不可见性的时候，定义了一个boolean值stop，但是线程读不到，所以停不下来，但是：

![image-20220925132109758](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925132109758.png)

![image-20220925132120471](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925132120471.png)

就变成可见性了

> 可见性

原理：

禁用缓存

![image-20220925132313149](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925132313149.png)

![image-20220925132454995](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925132454995.png)

> 有序性

![image-20220925133753107](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925133753107.png)

指令重排序

x86结构下面提供了

![image-20220925133950307](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925133950307.png)

![image-20220925134157833](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925134157833.png)

![image-20220925135218492](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925135218492.png)

### final域

![image-20220925135354366](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925135354366.png)



![image-20220925141039544](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925141039544.png)

![image-20220925141058835](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925141058835.png)

![image-20220925141304002](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925141304002.png)

final域的重排序规则：

**在引用变量被任意线程可见之前，这个引用变量指向的对象的final域已经在构造函数中被正确初始化过**



还有一个保障是在构造函数内部，不能让这个这个变量引用被其他线程可见

![image-20220925145315354](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925145315354.png)

### Happens-Before规则

**可以理解为编译器自带的一些禁止重排序的规则**

![image-20220925145358015](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925145358015.png)

指令执行顺序会优化，导致可见性问题，但是HB规则的语句不会

![image-20221001165919117](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001165919117.png)

https://juejin.cn/post/6877769459562938381

> 程序顺序规则

as-if-serial

单线程中不管怎么重排序， 单线程的执行结果是不会改变的。

编译器、处理器都要遵守asifserial语义，不会对有数据依赖关系的数据重排序



> 监视器锁规则

![image-20221001201151843](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001201151843.png)

这个是理所当然的“规则”



> volatile变量规则

对一个volatile域的写，hb于任意后续对这个volatile域的读



> 传递性

![image-20221001201615878](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001201615878.png)

> start()规则

![image-20221001202120834](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001202120834.png)



> join（）

![image-20221001202445293](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001202445293.png)

其他线程读到之后，var还是66

### 原子类Atomic

**无锁工具的典范**

```java
// 参数是初始大小
private static AtomicInteger atomicInteger = new AtomicInteger(0);


atomicInteger.incrementAndGet();
```



因为加锁势必会带来性能问题，所以无锁化编程



> 实现原理



![image-20221001203409799](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001203409799.png)



valueOFFset是: 这个原子类在内存中的偏移量

![image-20221001203808806](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001203808806.png)



unsafe中的方法：

![image-20221001204250672](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001204250672.png)

类似乐观锁

里面一直在循环，在执行，这里的性能消耗可以忽略

只有等offset（value）等于了expect才会跳出循环

![image-20221001204847358](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001204847358.png)



还有很多原子类：

![image-20221001205309811](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205309811.png)

![image-20221001205258162](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205258162.png)

### ThreadLocal实现原理

Demo：

![image-20221001205515604](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205515604.png)

这里的每个线程的结果都是不确定的

![image-20221001205559121](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205559121.png)

比如这里希望每个线程刚开始的时候都拿到的是0



![image-20221001205850280](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205850280.png)



![image-20221001205912030](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205912030.png)



![image-20221001205929250](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001205929250.png)

**可以看到这里线程之间产生隔离了，值设置回去了也不会对其他线程产生影响**

> 实现原理

![image-20221001211000080](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001211000080.png)

如果map为空

![image-20221001211156329](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001211156329.png)

![image-20221001211338649](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001211338649.png)

![image-20221001211450191](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001211450191.png)

上面有计算hashcode的过程

也包含一些，动态扩容、清除空key的等等......

每个线程的值都是完全隔离的

![image-20221001211852953](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001211852953.png)

## 4）如何安全发布对象

### 发布与逃逸

> # 发布

就和我们发布war包，别人就能用到了一样

![image-20221001212043717](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221001212043717.png)

![image-20221026145210269](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221026145210269.png)

> 不安全发布

不应该发布的对象被发布了

![image-20221026145545344](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221026145545344.png)

私有数据变成公有的了



> # 对象溢出

逃逸带来可见性问题

![image-20221026211832451](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221026211832451.png)

### 安全发布对象的四种方法

![image-20221027145322601](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027145322601.png)

![image-20221027152527395](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027152527395.png)

类似于这样...看不懂

## 5）JUC核心之AQS

### 重入锁ReentrantLock的初步认识

ReentrantLock

![image-20220925145743609](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925145743609.png)

![image-20220925150422787](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925150422787.png)

![image-20220925150758431](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925150758431.png)

> 锁的类图

![image-20220925150914440](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220925150914440.png)

### `AQS`是什么

我们先看类的关系：

![image-20221027155852924](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027155852924.png)

用到上面一节的例子：

```java
package JUC;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author: sc
 * @Date: 2022/10/27 17:02
 */
public class AQSDemo {

    static Lock lock = new ReentrantLock();
    public static int count = 0;
    public static void incr(){
        try{
            lock.lock();
            Thread.sleep(1);
            count++;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public static void decr(){
        lock.lock();
        count--;
        lock.unlock();
    }

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0;i<1000;i++){
            new Thread(AQSDemo::incr).start();
        }
        Thread.sleep(4000);
        System.out.println("result:"+count);
    }

}
```

> ## 我们来看lock

```java
public void lock() {
    sync.lock();
}
```

lock有两个实现类：（ctrl+alt+click查看实现类）

![image-20221027171853070](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027171853070.png)

公平锁和非公平锁我就不介绍了（是否根据排队的顺序）

我们点到`Reentrantlock`里面可以看到里面是非公平锁

```java
public ReentrantLock() {
    sync = new NonfairSync();
}
```

我们根据实现类找到他的非公平锁的lock的实现：

```java
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    @ReservedStackAccess
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}
```

cas修改state的值

```java
protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
// 返回一个boolean
```

你要互斥肯定需要一个共享资源，state（stateOffset）就是这个共享资源，**它是`AQS`工具类里的一个成员变量**

```java
/**
 * The synchronization state.
 */
private volatile int state; // 0没锁  大于1有锁
```

只是改了一个参数就行了！优雅

如果上面的`cas`函数返回true， 然后再使用一个独占线程的方法，将他独占

```java
protected final void setExclusiveOwnerThread(Thread thread) {
    exclusiveOwnerThread = thread;
}
```



这时候，来了线程B、C怎么办呢？然后还有else里的方法acquire 

```java
@ReservedStackAccess
final void lock() {
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
```

```java
@ReservedStackAccess
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

尝试去获取锁

```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
```

```java
@ReservedStackAccess
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {// 获取state发现为0，说明无锁，直接占用
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {// 是不是重入状态
        int nextc = c + acquires;// 只要记录重入次数
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

addWaitter方法，**实质上是构建了一个双向链表**

这里可以画个图清楚一些：

![image-20221027162425252](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027162425252.png)

构建节点（排队）

```java
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
```

阻塞：

```java
@ReservedStackAccess
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) { // 死循环  tryAcquire尝试去获取节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&// 如果获取失败的话就阻塞
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```java
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        /*
         * This node has already set status asking a release
         * to signal it, so it can safely park.
         */
        return true;
    if (ws > 0) {
        /*
         * Predecessor was cancelled. Skip over predecessors and
         * indicate retry.
         */
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    } else {
        /*
         * waitStatus must be 0 or PROPAGATE.  Indicate that we
         * need a signal, but don't park yet.  Caller will need to
         * retry to make sure it cannot acquire before parking.
         */
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}
```

```java
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); // 线程B、C会被阻塞在这个位置    （unpark接触阻塞）
    return Thread.interrupted();
}
```

唤醒：

`AQS`的`unpark`方法

> ## 现在我们来看unlock

唤醒阻塞的线程

```java
public void unlock() {
    sync.release(1);
}
```

```java
@ReservedStackAccess
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

```java
@ReservedStackAccess
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);// 恢复成默认样子
    }
    setState(c);
    return free;
}
```

唤醒：

```java
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

B就消失了

![image-20221027165012264](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221027165012264.png)

### CountDonLatch的基本使用

![image-20221028160130249](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221028160130249.png)

```java
/**
 * @Author: sc
 * @Date: 2022/10/28 16:01
 */
public class CountDownLatchDemo {

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(3);

        new Thread(()->{
            countDownLatch.countDown();
        }).start();// 倒计时3-1

        new Thread(()->{
            countDownLatch.countDown();
        }).start();// 倒计时2-1
        
        new Thread(()->{
            countDownLatch.countDown();
        }).start();// 倒计时1-1

        countDownLatch.await();
        System.out.println("线程执行完毕");
    }

}
```

![image-20221109133632433](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109133632433.png)

但是当我们将最后一个线程注释掉再执行：

![image-20221109133723436](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109133723436.png)

可以发现线程一直没结束

![image-20221109133755403](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109133755403.png)

应用：

可以模仿并发场景（一声令下，一千个被阻塞的线程都停下来了）

```java
/**
 * @Author: sc
 * @Date: 2022/11/9 13:43
 */
public class App implements Runnable{
    static CountDownLatch countDownLatch = new CountDownLatch(1);

    public static void main(String[] args) {
        for(int i=0;i<1000;i++){
            new Thread(new App()).start();
        }
        // 一声令下
        countDownLatch.countDown();
    }

    @Override
    public void run() {
        try {
            countDownLatch.await();
            // TODO
            // 业务逻辑
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

### CountDownLatch的源码分析

用到了AQS的**共享锁**的功能，reentrantLock可重入锁的原理是AQS的**互斥锁**

```java
public CountDownLatch(int count) {
    if (count < 0) throw new IllegalArgumentException("count < 0");
    this.sync = new Sync(count);
}
```

```java
Sync(int count) {
    setState(count);
}
```

（Sync是继承的AQS）

设置给了AQS里面的state！

下面我们就可以直接根据这个state的改变来研究源码

await方法：

```java
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```

```java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
```

```java
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}// 举个例子：这里只有当我们上面那个三个线程都执行了，才会返回1，否则返回-1
```

```java
private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);// 共享锁的节点！！！添加到一个AQS队列里，和之前一样
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);// 这个就是上面的方法
                if (r >= 0) {// 当三个线程都走完了才会到这一步
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&// 改变前置节点的状态
                parkAndCheckInterrupt()) // 把线程阻塞在这里
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

countDown方法就应该是一次一次地修改state的值（-1）

并且通过CAS修改state的值

```java
public void countDown() {
    sync.releaseShared(1);
}
```

```java
@ReservedStackAccess
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {// 直到三个state==0才会执行这个
        doReleaseShared();
        return true;
    }
    return false;// 上面的例子这个boolean值没有用到
}
```

```java
protected boolean tryReleaseShared(int releases) {// 修改count的值
    // Decrement count; signal when transition to zero
    for (;;) {
        int c = getState();
        if (c == 0)
            return false;
        int nextc = c-1;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
```

然后unpark释放阻塞

> 疑难点：    队列+释放阻塞

大概意思就不看源码了

拿上面的1000个线程阻塞的例子来看

![image-20221109150645429](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109150645429.png)

通过**循环**不断唤醒**下一个节点**：

![image-20221109150711432](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109150711432.png)

```java
static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1;
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1;
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3;
}
```

这里的Node有很多状态，其中的PROPAGATE翻译过来就是传播，就是上面说的一个一个循环唤醒的状态

### Semaphore的基本使用

![image-20221109151845205](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109151845205.png)

信号灯      限流

```java
/**
 * @Author: sc
 * @Date: 2022/11/9 15:20
 */
public class SemaphoreDemo {
    // 模拟上面的例子
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(5);
        for(int i=0;i<10;i++){
            new Car(i,semaphore).start();
        }
    }
    static class Car extends Thread{
        private int num;
        private Semaphore semaphore;

        public Car(int num, Semaphore semaphore) {
            this.num = num;
            this.semaphore = semaphore;
        }
        @Override
        public void run(){
            try {
                // 获得许可
                semaphore.acquire();
                System.out.println("第"+num+"占用一个停车位");
                TimeUnit.SECONDS.sleep(2);
                System.out.println("第"+num+"走了");
                // 释放许可
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

![image-20221109153203114](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221109153203114.png)

### Semaphore源码分析

```java
public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}
```

```java
NonfairSync(int permits) {
    super(permits);
}
```

```java
Sync(int permits) {
    setState(permits);
}
```

**可以看到还是设置了AQS工具类里的state属性**

> ## acquire方法

```java
public void acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
```

```java
public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) < 0)
        doAcquireSharedInterruptibly(arg);
}
```

（查看实现方法快捷键 Ctrl+Alt+B）

![image-20221110142823444](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221110142823444.png)

```java
final int nonfairTryAcquireShared(int acquires) {// 令牌的处理方式
    for (;;) {
        int available = getState();// 5
        int remaining = available - acquires;// 减去
        if (remaining < 0 ||
            compareAndSetState(available, remaining))// 小于0或者CAS失败 注意这个顺序，小于0的话就不CAS
            return remaining;
    }
}
```

这里是非公平的实现方式，但是公平的实现方式也差不多，我们一起看一下

```java
    protected int tryAcquireShared(int acquires) {
        for (;;) {
            if (hasQueuedPredecessors())// 多了一步加入队列的过程，非公平的不管前面有没有都先去抢占试一下
                return -1;
            int available = getState();
            int remaining = available - acquires;
            if (remaining < 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }
}
```

```java
private void doAcquireSharedInterruptibly(int arg)// 如果上面的semaphore不小于0的话返回成功之后到这个方法
    throws InterruptedException { // 还是一个共享锁的实现
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

> ## release方法

```java
public void release() {
    sync.releaseShared(1);
}
```

```java
@ReservedStackAccess
public final boolean releaseShared(int arg) {// arg是一个，对应释放一个令牌
    if (tryReleaseShared(arg)) {// 下面的方法对应state+1
        doReleaseShared();// 进行释放
        return true;
    }
    return false;
}
```

```java
protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next < current) // overflow
            throw new Error("Maximum permit count exceeded");
        if (compareAndSetState(current, next))
            return true;
    }
}
```

```java
private void doReleaseShared() { // 唤醒处于阻塞队列的源码
    /*
     * Ensure that a release propagates, even if there are other
     * in-progress acquires/releases.  This proceeds in the usual
     * way of trying to unparkSuccessor of head if it needs
     * signal. But if it does not, status is set to PROPAGATE to
     * ensure that upon release, propagation continues.
     * Additionally, we must loop in case a new node is added
     * while we are doing this. Also, unlike other uses of
     * unparkSuccessor, we need to know if CAS to reset status
     * fails, if so rechecking.
     */
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);
            }
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
```

### CyclicBarrier的基本使用

![image-20221110144642338](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221110144642338.png)

我们可以看到CycliBarrier有两个构造方法：

![image-20221112204029435](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112204029435.png)

```java
/**
 * @Author: sc
 * @Date: 2022/11/10 14:58
 */
public class DataImportThread extends Thread{

    private CyclicBarrier cyclicBarrier;
    private String path;

    public DataImportThread(String path, CyclicBarrier cyclicBarrier)
    {
        this.cyclicBarrier = cyclicBarrier;
        this.path = path;
    }


    @Override
    public void run() {
        System.out.println("开始导入"+path+"位置的数据");
        try {
            // 导入完成之后进行阻塞，等待汇总
            cyclicBarrier.await();
        } catch (InterruptedException | BrokenBarrierException e) {
            e.printStackTrace();
        }
    }
}
```

```java
/**
 * @Author: sc
 * @Date: 2022/11/10 14:45
 */
public class CyclicBarrierDemo extends Thread {
    @Override
    public void run() {
        System.out.println("开始进行数据汇总和分析");
    }

    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new CyclicBarrierDemo());
        new DataImportThread("path1", cyclicBarrier).start();
        new DataImportThread("path2", cyclicBarrier).start();
        new DataImportThread("path3", cyclicBarrier).start();
        // 三个线程执行之后再汇总处理
        

    }
}
```

不管怎么执行，都是等三个子线程执行完了之后，最后执行CycliBarrier的run方法

![image-20221112210206733](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112210206733.png)

> 存在一定的问题

1、某种原因没有足够多的线程来调用await，会导致所有线程都会被阻塞

2、await（timeout，unit）设置一个超时等待时间

3、reset（）重置计数器

### CyclicBarrier的源码分析

![image-20221112211807205](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112211807205.png)

![image-20221112211832190](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112211832190.png)

子线程在运行到await之后就卡住了

等n个子线程执行完

![image-20221112211934562](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112211934562.png)

就执行后面的东西// TODO

然后就会进入**下一个循环**，这里叫做一个周期（generation）

> 源码

初始构建了一个count值

![image-20221112234018852](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112234018852.png)

这里的Command可以认为是上面例子里**主线程的run方法**

我们先来看子线程里的await方法：

```java
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}
```

```java
private int dowait(boolean timed, long nanos)
    throws InterruptedException, BrokenBarrierException,
TimeoutException {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        final Generation g = generation;// 这个就是上面说的“朝代”
        if (g.broken)
            throw new BrokenBarrierException();
        if (Thread.interrupted()) {
            breakBarrier();
            throw new InterruptedException();
        }
        int index = --count;// count 就相当于state了
        if (index == 0) {  // tripped  如果count == 0 的话就执行下面的方法
            boolean ranAction = false;
            try {
                final Runnable command = barrierCommand;
                if (command != null)
                    command.run();
                ranAction = true;
                nextGeneration();  // 这个方法的源码在下面  唤醒所有被阻塞的线程 notifyAll() 然后更换generation
                return 0;// 正常就到这里结束了 下一个周期
            } finally {
                if (!ranAction)
                    breakBarrier(); 
            }
        }
			// 但是还有很多异常代码
        // loop until tripped, broken, interrupted, or timed out
        for (;;) {
            try {
                if (!timed)// 如果构造函数里面有时间限制就会执行下面的，没有的话执行下下面的
                    trip.await();  // 共享锁的逻辑实现一个队列
                else if (nanos > 0L)
                    nanos = trip.awaitNanos(nanos);
            } catch (InterruptedException ie) {
                if (g == generation && ! g.broken) {
                    breakBarrier();
                    throw ie;
                } else {
                    // We're about to finish waiting even if we had not
                    // been interrupted, so this interrupt is deemed to
                    // "belong" to subsequent execution.
                    Thread.currentThread().interrupt();  // 被中断
                }
            }
            if (g.broken)
                throw new BrokenBarrierException();
            if (g != generation)
                return index;
            if (timed && nanos <= 0L) { // 超时了，报异常
                breakBarrier();// 打破当前的屏障
                throw new TimeoutException();
            }
        }
    } finally {
        lock.unlock();
    }
}
```

![image-20221112234457112](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112234457112.png)


### condition条件

JUC里面提供的wait和notify

![image-20221112235544655](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221112235544655.png)

简单来创建两个线程

```java
/**
 * @Author: sc
 * @Date: 2022/11/13 0:01
 */
public class ConditionDemoWait extends Thread {

    private Lock lock;

    private Condition condition;

    public ConditionDemoWait(Lock lock, Condition condition) {
        this.lock = lock;
        this.condition = condition;
    }

    @Override
    public void run() {
        System.out.println("begin - ConditionDemoWait");
        try {
            lock.lock();
            // 这个await也是必须放在锁的范围之内, 和wait notify一样，之前是加synchronized
            // 这里为什么必须要加锁？？？
            condition.await();
            System.out.println("end - ConditionDemoWait");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

```java
/**
 * @Author: sc
 * @Date: 2022/11/13 0:01
 */
public class ConditionDemoNotify extends Thread {

    private Lock lock;

    private Condition condition;

    public ConditionDemoNotify(Lock lock, Condition condition) {
        this.lock = lock;
        this.condition = condition;
    }

    @Override
    public void run() {
        System.out.println("begin - ConditionDemoNotify");
        try {
            lock.lock();
            // 这个await也是必须放在锁的范围之内, 和wait notify一样，之前是加synchronized
            // 这里为什么必须要加锁？？？
            condition.signal();
            System.out.println("end - ConditionDemoNotify");
        } finally {
            lock.unlock();
        }
    }
}
```

```java
/**
 * @Author: sc
 * @Date: 2022/11/12 23:58
 */
public class ConditionDemo {
    public static void main(String[] args) {
        // 两个线程必须持有同一把锁，并且在一个条件下
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        ConditionDemoWait conditionDemoWait = new ConditionDemoWait(lock, condition);
        ConditionDemoNotify conditionDemoNotify = new ConditionDemoNotify(lock, condition);

        conditionDemoWait.start();
        conditionDemoNotify.start();
    }
}
```

![image-20221113001425718](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113001425718.png)

这里的执行顺序是不会变的

满足**条件**的就会被阻塞

```java
static final class Node {
    /** Marker to indicate a node is waiting in shared mode */
    static final Node SHARED = new Node();
    /** Marker to indicate a node is waiting in exclusive mode */
    static final Node EXCLUSIVE = null;

    /** waitStatus value to indicate thread has cancelled */
    static final int CANCELLED =  1;
    /** waitStatus value to indicate successor's thread needs unparking */
    static final int SIGNAL    = -1;
    /** waitStatus value to indicate thread is waiting on condition */
    static final int CONDITION = -2;
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
    static final int PROPAGATE = -3;
}
```

两个队列相互维护

![image-20221113131043812](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113131043812.png)

## 6）线程调度值线程池

### 线程池的基本认识

**线程+池**

**复用连接，避免频繁销毁**

> 好处

1、降低创建线程和销毁线程的性能开销

2、提高响应速度，当有新的任务需要执行时，不需要等待线程创建就可以立马执行

3、合理的设置线程池大小可以避免因为线程数超过硬件资源瓶颈带来的问题

### 线程池的使用

```java
package ExecutorService;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorDemo implements Runnable {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ExecutorDemo());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
```

![image-20221113141956132](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113141956132.png)

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

再比如一个newFixedThreadPool，也是返回的ExecutorService对象

![image-20221113142445037](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113142445037.png)

区别是，返回对象的参数不一样！

再比如，newSingleThreadExectuor

![image-20221113142550732](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113142550732.png)

> ## 参数

![image-20221113142750597](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113142750597.png)

拿newCachedThreadPool举个例子

可以看到核心线程数是0，最大线程数是Integer最大

![image-20221113143051312](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113143051312.png)

### 线程池的基本原理

![image-20221113144133829](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113144133829.png)

![image-20221113145112069](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20221113145112069.png)

### 一步步分析线程池的源码

源码分析：

![image-20221124194727723](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124194727723.png)

AddWorker

拒绝策略：

![image-20221124201944065](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124201944065.png)

看到代码就很清楚

### 线程池的使用

![image-20221124202124084](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124202124084.png)

创建固定数量的线程

只有一个线程的线程池

动态调整

规划

比如fixed的：

```java
package com.suncong.JUC;

import java.util.concurrent.*;

/**
 * @author SunCong
 * @date 2022/11/24 19:51
 */
public class ExecutorDemo implements Runnable {

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 100; i++) {
            executorService.execute(new ExecutorDemo());
        }
        executorService.shutdown();
    }

    @Override
    public void run() {
        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName());
    }
}
```

可以看到只有1、2、3、循环

![image-20221124202858128](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124202858128.png)

### 线程池的监控

想要监控线程池我们可以使用自己定义的线程池，当然，可以抄参数

```java
package com.suncong.JUC;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author SunCong
 * @date 2022/11/24 20:31
 */
public class MyThreadPool extends ThreadPoolExecutor {
    public MyThreadPool(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }
}
```

我们自己定义了线程池就可以重写很多方法：

![image-20221124203739883](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124203739883.png)

比如这两个，线程池执行之前和之后可以打印信息

```java
@Override
protected void beforeExecute(Thread t, Runnable r) {
    super.beforeExecute(t, r);
}

@Override
protected void afterExecute(Runnable r, Throwable t) {
    System.out.println("初始线程数"+this.getPoolSize());
    System.out.println("核心线程数"+this.getCorePoolSize());
    System.out.println("正在执行的任务数量"+this.getActiveCount());
    System.out.println("已经执行的任务数"+this.getCompletedTaskCount());
}
```

注：这个执行之前和之后并非按照线程池的生命周期，而是一个run方法执行前后，一个线程就有一个run方法

> 预热所有核心线程

executorService.prestartAllCoreThreads()

### 带返回值的线程处理

```java
package com.suncong.JUC;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

/**
 * @author SunCong
 * @date 2022/11/24 21:00
 */
public class CallableFutureDemo implements Callable<String> {

    @Override
    public String call() throws Exception {
        System.out.println("Hello World!");
        Thread.sleep(3000);
        return "睡醒了！";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableFutureDemo callableFutureDemo = new CallableFutureDemo();
        FutureTask futureTask = new FutureTask(callableFutureDemo);
        new Thread(futureTask).start();
        System.out.println(futureTask.get());
    }

}
```

![image-20221124210255888](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124210255888.png)

```java
@FunctionalInterface
public interface Callable<V> {
    /**
     * Computes a result, or throws an exception if unable to do so.
     *
     * @return computed result
     * @throws Exception if unable to compute a result
     */
    V call() throws Exception;
}
```

```java
public class FutureTask<V> implements RunnableFuture<V> 
```

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

![image-20221124210638991](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124210638991.png)

> 线程池如何实现callable的调用

```java
package com.suncong.JUC;

import java.util.concurrent.*;

/**
 * @author SunCong
 * @date 2022/11/24 21:00
 */
public class CallableFutureDemo implements Callable<String> {

    @Override
    public String call() throws Exception {
        System.out.println("Hello World!");
        Thread.sleep(3000);
        return "睡醒了！";
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {

        ExecutorService executorService = Executors.newFixedThreadPool(1);
        CallableFutureDemo callableFutureDemo = new CallableFutureDemo();
        FutureTask futureTask  = (FutureTask) executorService.submit(callableFutureDemo);
        System.out.println(futureTask.get());
    }

}
```

## 7）多并发编程拓展

### 死锁了怎么办

转账的例子：

![image-20221124212930265](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124212930265.png)

![image-20221124213036850](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124213036850.png)

发生死锁，或者一段时间之后发生死锁

> 死锁条件

![image-20221124213201203](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20221124213201203.png)

破坏其中一个条件就行

第一个条件不行，锁的原理

第二个一次性申请所有资源

第三个一段时间之后释放手里的资源或者用tryLock等方法返回bool，就不会不可抢占了

第四个预占有资源

### ConcurrentHashMap原理

JUC包里提供的一个线程安全并且高效的HashMap

![image-20230128171322499](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230128171322499.png)

链表数>8时，会变成红黑树

put方法：

![image-20230128171455068](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230128171455068.png)

![image-20230128171614922](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230128171614922.png)

![image-20230128171852419](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230128171852419.png)

可能hash值不同的计算出来的下标在一个位置

![image-20230128172029521](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230128172029521.png)

# Q&A



































