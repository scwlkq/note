## 一些心得

递归的题目确定要每个函数返回的是啥就清楚了





## STL的API

### unordered_map

![image-20230111094847414](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230111094847414.png)

### string的api



### vector的api

https://blog.csdn.net/weixin_44607113/article/details/123738389?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167366210316800184195899%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167366210316800184195899&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-123738389-null-null.142^v71^control,201^v4^add_ask&utm_term=vector%E7%94%A8%E6%B3%95&spm=1018.2226.3001.4187

![image-20230114202713521](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202713521.png)

![image-20230114202736825](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202736825.png)

![image-20230114202855602](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202855602.png)

 	![image-20230114202909202](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202909202.png)

![image-20230114202928652](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202928652.png)

![image-20230114202936683](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114202936683.png)

### queue常用api

#### C++

![image-20230114204125997](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114204125997.png)

#### Java

![image-20230114212101148](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114212101148.png)

































## 基础算法

### 快速排序

基于分治

1、确定分界点

2、调整范围

3、递归处理

![image-20220810143949064](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810143949064.png)

优雅写法（双指针）

![image-20220810145524514](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810145524514.png)

一直交换直到两个指针相遇

会有很多边界问题（这里就建议背模板）

注意分治的时候如果分是根据j的话x不能去右边界，左边同理

```c++
#include<iostream> 
using namespace std;
const int N = 1e6 + 10;
int n;
int q[N];
void quick_sort(int q[], int l, int r) {
    if (l >= r) return;
    // 这里尽量就取中间
    int x = q[(l+r)/2];
    // 这里有个偏移量和下面的等号和dowhile有关
    int i = l - 1, j = r + 1;
    while(i < j) {
        // 这里不能加等号
        do i++;	while (q[i] < x);
        // 这里不能加等号
        do j--;	while (q[j] > x);
        if(i<j) swap(q[i], q[j]);
    }
    // 这里就背j
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++)	scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i++)	printf("%d ", q[i]);
    return 0;
}
```

![image-20220810155456208](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810155456208.png)

时间复杂度平均是O(nlogn），最坏是n平方

第k个数（快速选择）

快排是O（nlogn），快选是O（n）

![image-20220830133224857](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220830133224857.png)

![image-20220810160654426](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810160654426.png)

![image-20220810160758851](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810160758851.png)

![image-20220810160526943](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810160526943.png)

### 归并排序

![image-20220810162604292](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810162604292.png)

![image-20220810165852136](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810165852136.png)

归并是稳定的，就是原序列相同值的元素的位置排序之后不会发生改变，快排不是

时间O(nlogn）

每层时间复杂度都是O(n)，n一共要分logn次才能变成1

![image-20220810170425004](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220810170425004.png)

```c++
#include<iostream> 
using namespace std;
const int N = 1e6 + 10;
int n;
int q[N], tmp[N];
void merge_sort(int q[], int l, int r) {
	if (l >= r) return;
	int mid = l+r>>1;
	merge_sort(q,l,mid), merge_sort(q,mid+1,r);
	int k=0,i=l,j=mid+1;
	while(i<=mid&&j<=r)
		if(q[i]<=q[j]) tmp[k++] = q[i++];
		else tmp[k++] = q[j++];
	while(i<=mid) tmp[k++] = q[i++];
	while(j<=r) tmp[k++] = q[j++];
	for(int i=l, j=0;i<=r;i++, j++) q[i] = tmp[j];
}
int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; i++)	scanf("%d", &q[i]);
	merge_sort(q, 0, n - 1);
	for (int i = 0; i < n; i++)	printf("%d ", q[i]);
	return 0;
}
```

逆序对的数量

int 21亿左右

```java
class Solution {
    
    int res;
    int[] tmp = new int[50000];
    int merge_sort(int l, int r,int[] q){
        if(l>=r) return 0;

        int mid = l+r>>1;
        int res = merge_sort(l,mid,q)+merge_sort(mid+1,r,q);
        //归并
        int k =0,i=l,j=mid+1;
        while(i<=mid&&j<=r)
            if(q[i]<=q[j]) tmp[k++] = q[i++];
            else{
                tmp[k++] = q[j++];
                res+=mid-i+1;
            }
        while(i<=mid)tmp[k++] = q[i++];
        while(j<=r) tmp[k++] = q[j++];
        for(int ii=l,jj=0;ii<=r;ii++,jj++) q[ii] = tmp[jj];

        return res;    
    }

    public int reversePairs(int[] nums) {
        return merge_sort(0,nums.length-1, nums);
    }
}
```

### 二分查找

模板：

```c++
// 区间【1，r】被划分成【1，mid】和【mid+1，r】时使用 
int bsearch_1(int l, int r) {
	while(l<r) {
		int mid = l+r>>1;
		if(check(mid)) r =mid;
		else l=mid+1;
	}
	return l;
}

// 区间【1，r】被划分成【1，mid-1】和【mid，r】时使用  
int bsearch_2(int l, int r) {
	while(l<r) {
		int mid = l+r+1>>1;
		if(check(mid)) l=mid;
		else r = mid-1;
	}
	return l;
}
```

#### 整数二分

![image-20230111105147379](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230111105147379.png)

![image-20230111105221196](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230111105221196.png)

![image-20220820210759086](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220820210759086.png)

浮点数二分（三次方根）

![image-20220821095126786](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220821095126786.png)

数的三次方根

![image-20220830202641637](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220830202641637.png)

### 高精度乘除加减法

加法：

```C++
#include <iostream>
#include <vector>

using namespace std;

vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}

int main()
{
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');

    auto C = add(A, B);

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
    cout << endl;

    return 0;
}
```



减法：

```C++
#include <iostream>
#include <vector>

using namespace std;

bool cmp(vector<int> &A, vector<int> &B)
{
    if (A.size() != B.size()) return A.size() > B.size();

    for (int i = A.size() - 1; i >= 0; i -- )
        if (A[i] != B[i])
            return A[i] > B[i];

    return true;
}

vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i -- ) B.push_back(b[i] - '0');

    vector<int> C;

    if (cmp(A, B)) C = sub(A, B);
    else C = sub(B, A), cout << '-';

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];
    cout << endl;

    return 0;
}


```



乘法：

```C++
#include <iostream>
#include <vector>

using namespace std;


vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}


int main()
{
    string a;
    int b;

    cin >> a >> b;

    vector<int> A;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');

    auto C = mul(A, b);

    for (int i = C.size() - 1; i >= 0; i -- ) printf("%d", C[i]);

    return 0;
}
```



除法：

```C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}

int main()
{
    string a;
    vector<int> A;

    int B;
    cin >> a >> B;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');

    int r;
    auto C = div(A, B, r);

    for (int i = C.size() - 1; i >= 0; i -- ) cout << C[i];

    cout << endl << r << endl;

    return 0;
}
```

### 前缀和与差分

> 一维前缀和

![image-20220830223935098](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220830223935098.png)

注意这个S0=0；数组的下标也是从0开始的

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], s[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i]; // 前缀和的初始化

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]); // 区间和的计算

    }

    return 0;
}
```

> 二维前缀和

![image-20220905185649123](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220905185649123.png)

求红色区域的面积

![image-20220915161504305](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915161504305.png)



`s[i][j]`怎么算

![image-20220915162235385](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915162235385.png)

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n, m, q;
int s[N][N];

int main()
{
    scanf("%d%d%d", &n, &m, &q);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &s[i][j]);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

    while (q -- )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }

    return 0;
}
```



> 差分

差分是前缀和的逆运算

![image-20220915170220472](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915170220472.png)

可以简化操作O(n)到O（1）

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N];

void insert(int l, int r, int c)
{
    b[l] += c;
    b[r + 1] -= c;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    for (int i = 1; i <= n; i ++ ) insert(i, i, a[i]);

    while (m -- )
    {
        int l, r, c;
        scanf("%d%d%d", &l, &r, &c);
        insert(l, r, c);
    }

    for (int i = 1; i <= n; i ++ ) b[i] += b[i - 1];

    for (int i = 1; i <= n; i ++ ) printf("%d ", b[i]);

    return 0;
}

```

二维差分

![image-20220915172106131](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915172106131.png)

![image-20220915172123654](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915172123654.png)

```c++
#include <iostream>

using namespace std;

const int N = 1010;

int n, m, q;
int a[N][N], b[N][N];

void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}

int main()
{
    scanf("%d%d%d", &n, &m, &q);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &a[i][j]);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            insert(i, j, i, j, a[i][j]);

    while (q -- )
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];

    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) printf("%d ", b[i][j]);
        puts("");
    }

    return 0;
}


```

### 双指针算法

两种情况：

O(n^2)变成O(n)

![image-20220915172601985](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915172601985.png)

![image-20220915173035461](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220915173035461.png)

 



```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n;
int q[N], s[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    int res = 0;
    for (int i = 0, j = 0; i < n; i ++ )
    {
        s[q[i]] ++ ;
        while (j < i && s[q[i]] > 1) s[q[j ++ ]] -- ;
        res = max(res, i - j + 1);
    }

    cout << res << endl;

    return 0;
}

```

**先想暴力的，然后做优化**

![image-20220916224947355](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220916224947355.png)

```c++

#include <iostream>
#include <cstring>

using namespace std;

const int N = 100010;

int n, m;
int a[N], b[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    for (int i = 0; i < m; i ++ ) scanf("%d", &b[i]);

    int i = 0, j = 0;
    while (i < n && j < m)
    {
        if (a[i] == b[j]) i ++ ;
        j ++ ;
    }

    if (i == n) puts("Yes");
    else puts("No");

    return 0;
}

```

### 位运算

![image-20220916225811537](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220916225811537.png)

这个公式可以看n的第k位数字是几

lowbit（x）的作用

![image-20220916231239275](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220916231239275.png)

c++里取负是补码取反+1

![image-20220917184319625](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220917184319625.png)

应用：

统计x里1的个数

```c++
#include <iostream>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int x, s = 0;
        scanf("%d", &x);

        for (int i = x; i; i -= i & -i) s ++ ;

        printf("%d ", s);
    }

    return 0;
}
```

![image-20220917185751355](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220917185751355.png)

### 离散化

![image-20220926125732030](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220926125732030.png)





![image-20220926133954630](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220926133954630.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 300010;

int n, m;
int a[N], s[N];

vector<int> alls;
vector<PII> add, query;

int find(int x)
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});

        alls.push_back(x);
    }

    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});

        alls.push_back(l);
        alls.push_back(r);
    }

    // 去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());

    // 处理插入
    for (auto item : add)
    {
        int x = find(item.first);
        a[x] += item.second;
    }

    // 预处理前缀和
    for (int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];

    // 处理询问
    for (auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }

    return 0;
}

```





### 区间合并

![image-20220926141006827](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220926141006827.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}

int main()
{
    int n;
    scanf("%d", &n);

    vector<PII> segs;
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        segs.push_back({l, r});
    }

    merge(segs);

    cout << segs.size() << endl;

    return 0;
}


```













​	

## 数据结构

### 单链表

![image-20220927131507745](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220927131507745.png)

```c++
#include <iostream>

using namespace std;

const int N = 100010;


// head 表示头结点的下标
// e[i] 表示节点i的值
// ne[i] 表示节点i的next指针是多少
// idx 存储当前已经用到了哪个点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 将x插到头结点
void add_to_head(int x)
{
    e[idx] = x, ne[idx] = head, head = idx ++ ;
}

// 将x插到下标是k的点后面
void add(int k, int x)
{
    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++ ;
}

// 将下标是k的点后面的点删掉
void remove(int k)
{
    ne[k] = ne[ne[k]];
}

int main()
{
    int m;
    cin >> m;

    init();

    while (m -- )
    {
        int k, x;
        char op;

        cin >> op;
        if (op == 'H')
        {
            cin >> x;
            add_to_head(x);
        }
        else if (op == 'D')
        {
            cin >> k;
            if (!k) head = ne[head];
            else remove(k - 1);
        }
        else
        {
            cin >> k >> x;
            add(k - 1, x);
        }
    }

    for (int i = head; i != -1; i = ne[i]) cout << e[i] << ' ';
    cout << endl;

    return 0;
}

```









### 双链表

![image-20220927135500894](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220927135500894.png)

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int e[N], l[N], r[N], idx;

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}

int main()
{
    cin >> m;

    // 0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;

    while (m -- )
    {
        string op;
        cin >> op;
        int k, x;
        if (op == "L")
        {
            cin >> x;
            insert(0, x);
        }
        else if (op == "R")
        {
            cin >> x;
            insert(l[1], x);
        }
        else if (op == "D")
        {
            cin >> k;
            remove(k + 1);
        }
        else if (op == "IL")
        {
            cin >> k >> x;
            insert(l[k + 1], x);
        }
        else
        {
            cin >> k >> x;
            insert(k + 1, x);
        }
    }

    for (int i = r[0]; i != 1; i = r[i]) cout << e[i] << ' ';
    cout << endl;

    return 0;
}

```



### 栈

![image-20220927140027571](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/image-20220927140027571.png)

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int stk[N], tt;

int main()
{
    cin >> m;
    while (m -- )
    {
        string op;
        int x;

        cin >> op;
        if (op == "push")
        {
            cin >> x;
            stk[ ++ tt] = x;
        }
        else if (op == "pop") tt -- ;
        else if (op == "empty") cout << (tt ? "NO" : "YES") << endl;
        else cout << stk[tt] << endl;
    }

    return 0;
}

```

表达式求值

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <stack>
#include <unordered_map>

using namespace std;

stack<int> num;
stack<char> op;

void eval()
{
    auto b = num.top(); num.pop();
    auto a = num.top(); num.pop();
    auto c = op.top(); op.pop();
    int x;
    if (c == '+') x = a + b;
    else if (c == '-') x = a - b;
    else if (c == '*') x = a * b;
    else x = a / b;
    num.push(x);
}

int main()
{
    unordered_map<char, int> pr{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};
    string str;
    cin >> str;
    for (int i = 0; i < str.size(); i ++ )
    {
        auto c = str[i];
        if (isdigit(c))
        {
            int x = 0, j = i;
            while (j < str.size() && isdigit(str[j]))
                x = x * 10 + str[j ++ ] - '0';
            i = j - 1;
            num.push(x);
        }
        else if (c == '(') op.push(c);
        else if (c == ')')
        {
            while (op.top() != '(') eval();
            op.pop();
        }
        else
        {
            while (op.size() && op.top() != '(' && pr[op.top()] >= pr[c]) eval();
            op.push(c);
        }
    }
    while (op.size()) eval();
    cout << num.top() << endl;
    return 0;
}
```



### 模拟队列

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int m;
int q[N], hh, tt = -1;

int main()
{
    cin >> m;

    while (m -- )
    {
        string op;
        int x;

        cin >> op;
        if (op == "push")
        {
            cin >> x;
            q[ ++ tt] = x;
        }
        else if (op == "pop") hh ++ ;
        else if (op == "empty") cout << (hh <= tt ? "NO" : "YES") << endl;
        else cout << q[hh] << endl;
    }

    return 0;
}

```







### 单调栈



















### 滑动窗口

```c++
//
// Created by SunCong on 2022/12/23.
//
#include <iostream>

using namespace std;

const int N = 1000010;

int a[N], q[N];

int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    int hh = 0, tt = -1;
    for (int i = 0; i < n; i++) {
        // 1.左窗口是被强制往右边拉的 一回合只能拉一次所以用if（因为只有一个元素）
        if (hh <= tt && i - k + 1 > q[hh])
            hh++;

        // 2.如果没有这一步 1和3就是大小为3的窗口一直往右 这一步是保证单调性
        while (hh <= tt && a[q[tt]] >= a[i])
            tt--;

        // 3.q 里存的是下标
        q[++tt] = i;

        if (i >= k - 1)
            // hh定位的是当前窗口内的最小值
            printf("%d ", a[q[hh]]);
    }

    puts("");

    hh = 0, tt = -1;
    for (int i = 0; i < n; i++) {
        if (hh <= tt && i - k + 1 > q[hh]) hh++;

        while (hh <= tt && a[q[tt]] <= a[i]) tt--;
        q[++tt] = i;

        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }

    puts("");

    return 0;
}
```

### KMP字符串

```c++
3
aba
5
ababa
```

```c++
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;

    // 求next数组
    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }

    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}

```



### Trie

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int son[N][26], cnt[N], idx;
char str[N];

void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx; // idx是多一个节点就会+1
        p = son[p][u];
    }
    cnt[p] ++ ; // p就是当前末尾字符对应的idx
}

int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        char op[2];
        scanf("%s%s", op, str);
        if (*op == 'I') insert(str);
        else printf("%d\n", query(str));
    }

    return 0;
}

```

#### 最大异或对

先暴力，然后优化

 ```c++
 #include <iostream>
 #include <algorithm>
 
 using namespace std;
 
 const int N = 100010, M = 3100010;
 
 int n;
 int a[N], son[M][2], idx;
 
 void insert(int x)
 {
     int p = 0;
     for (int i = 30; i >= 0; i -- )
     {
         int &s = son[p][x >> i & 1];
         if (!s) s = ++ idx;
         p = s;
     }
 }
 
 int search(int x)
 {
     int p = 0, res = 0;
     for (int i = 30; i >= 0; i -- )
     {
         int s = x >> i & 1;
         if (son[p][!s])
         {
             res += 1 << i;
             p = son[p][!s];
         }
         else p = son[p][s];
     }
     return res;
 }
 
 int main()
 {
     scanf("%d", &n);
     for (int i = 0; i < n; i ++ )
     {
         scanf("%d", &a[i]);
         insert(a[i]);
     }
 
     int res = 0;
     for (int i = 0; i < n; i ++ ) res = max(res, search(a[i));
 
     printf("%d\n", res);
 
     return 0;
 }
 
 ```

### 并查集

![image-20230108152741455](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108152741455.png)

一半的优化策略：路径压缩   接近O(1)

```c++
#include<iostream>

using namespace std;
const int N = 100010;
int m,n,p[N];

int find(int x){// 返回父节点并且路径压缩
    if(p[x]!=x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) p[i]=i;
    
    while(m--){
        char op[2];
        int x,y;
        scanf("%s%d%d",&op,&x,&y);
        
        if(*op =='M'){
            p[find(x)]=find(y);
        }else{
            if(find(x)==find(y)){
                puts("Yes");
            }else{
                puts("No");
            }
        }
    }
    
    return 0;
}
```

注意下标从1开始

#### 连通块中点的数量

![image-20230108190400522](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108190400522.png)

```c++
#include<iostream>

using namespace std;
const int N = 100010;

int p[N],cnt[N];// 只有根节点的size值才有用
int n, m;
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}

int main(){

    cin>>n>>m;
    for(int i=1;i<=n;i++){
        p[i]=i;
        cnt[i]=1;
    }
    while(m--){
        string op;
        int x,y;
        cin>>op;
        if(op=="C"){
            cin>>x>>y;
            
            if(find(x)==find(y)) continue;
            cnt[find(y)]+=cnt[find(x)];//这一步需要在前面
            p[find(x)]=find(y);

        }else if(op=="Q1"){
            cin>>x>>y;
            
            if(find(x)==find(y)){
                puts("Yes");
            }else{
                puts("No");
            }
        }else{
            cin>>x;
            cout<<cnt[find(x)]<<endl;
        }
    }
    return 0;
}
```

#### 食物链

并查集可以维护额外信息，上面的size就是一个

![image-20230108191321927](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108191321927.png)

![image-20230108191353554](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108191353554.png)

注意有个三角循环的关系，审题

  ```c++
  #include<iostream>
  
  using namespace std;
  
  const int N = 50010;
  
  int p[N],d[N];
  int m,n;
  
  int find(int x){
      if(p[x]!=x){
          int u = find(p[x]);
          d[x]+=d[p[x]];
          p[x]=u;
      }
      return p[x];
  }
  
  int main(){
      
      cin>>n>>m;
      for(int i=1;i<=n;i++){
          p[i]=i;
      }
      int res = 0;
      while(m--){
          int x,y,z;
          cin>>x>>y>>z;
          
          if(y>n||z>n){
              res++;
          }else{
              int py = find(y), pz = find(z);
              if(x==1){
                  if(py==pz && (d[y]-d[z])%3){
                      res++;
                  }else if(py!=pz){
                      p[py]=pz;
                      d[py]=d[z]-d[y];
                  }
              }else{
                  if(py==pz && (d[y]-d[z]-1)%3){
                      res++;
                  }else if(py!=pz){
                      p[py]=pz;
                      d[py]=d[z]+1-d[y];
                  }
              }
          }
      }
      cout<<res<<endl;
      return 0;
  }
  ```

### 堆

![image-20230108231509969](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108231509969.png)

完全二叉树

 ![image-20230108231329727](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108231329727.png)

```c++
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;

const int N = 100010;
ll h[N];
int len;

int down(int x){
    int min_index=x;
    if(2*x<=len&&h[min_index]>=h[2*x]) {
        min_index=2*x;
    }
    if((2*x+1)<=len&&h[min_index]>=h[(2*x+1)]) {
        min_index=(2*x+1);
    }
    if(min_index!=x){
        swap(h[min_index],h[x]);
        down(min_index);
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    len=n;
    //这里下标从1开始
    for(int i =1;i<=n;i++){
        cin>>h[i];
    }
    
    // 排序
    // 这里可以从n/2开始算的原因是叶子结点已经满足性质（因为无子孙结点）
    for(int i=n/2;i;i--){
        down(i);
    }
    
    while(m--){
        cout<<h[1]<<" ";
        h[1]=h[len];
        len--;
        down(1);
    }
    return 0;
}
```

#### 模拟堆

![image-20230108233755984](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108233755984.png)

![image-20230108233816690](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108233816690.png)

交换操作：

![image-20230108234304424](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230108234304424.png)

这题由于需要动态维护一个一对一的指针

```c++
// 小根堆
#include <iostream>
#include <algorithm>
#include <string.h>

using namespace std;

const int N = 100010;

int h[N], ph[N], hp[N], cnt;

void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= cnt && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= cnt && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

int main()
{
    int n, m = 0;// m维护的是当前是插入的第几个数字
    scanf("%d", &n);
    while (n -- )
    {
        char op[5];
        int k, x;
        scanf("%s", op);
        if (!strcmp(op, "I"))
        {
            scanf("%d", &x);
            cnt ++ ;
            m ++ ;
            ph[m] = cnt, hp[cnt] = m;
            h[cnt] = x;
            up(cnt);
        }
        else if (!strcmp(op, "PM")) printf("%d\n", h[1]);
        else if (!strcmp(op, "DM"))
        {
            heap_swap(1, cnt);
            cnt -- ;
            down(1);
        }
        else if (!strcmp(op, "D"))
        {
            scanf("%d", &k);
            k = ph[k];
            heap_swap(k, cnt);
            cnt -- ;
            up(k);
            down(k);
        }
        else
        {
            scanf("%d%d", &k, &x);
            k = ph[k];
            h[k] = x;
            up(k);
            down(k);
        }
    }

    return 0;
}
```





### 哈希表

![image-20230110230419464](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230110230419464.png)

数学上可以证明hash 的长度取质数并且是离2的次幂越远

hash冲突的概率越低

拉链法：

![image-20230109153354426](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230109153354426.png)

开放寻址法：

跟蹲坑位是一个道理

```c++
#include<iostream>
#include<cstring>

const int N = 200003, null = 0x3f3f3f3f;

int h[N];

int find(int x){
    int t = (x % N + N) % N;
    while (h[t] != null && h[t] != x)
    {
        t ++ ;
        if (t == N) t = 0;
    }
    return t;
}

int main(){
    
    memset(h, 0x3f3f3f3f, sizeof h);

    int n;
    scanf("%d", &n);

    while (n -- )
    {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if (*op == 'I') h[find(x)] = x;
        else
        {
            if (h[find(x)] == null) puts("No");
            else puts("Yes");
        }
    }
    
}

```

####  字符串哈希

![image-20230111000143263](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230111000143263.png)

![image-20230110232255202](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230110232255202.png)

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef unsigned long long ULL;

const int N = 100010, P = 131;

int n, m;
char str[N];
ULL h[N], p[N];

ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main()
{
    scanf("%d%d", &n, &m);
    scanf("%s", str + 1);

    p[0] = 1;
    for (int i = 1; i <= n; i ++ )
    {
        h[i] = h[i - 1] * P + str[i];
        p[i] = p[i - 1] * P;
    }

    while (m -- )
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);

        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }

    return 0;
}
```

## 搜索与图论

![image-20230127160149966](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230127160149966.png)

### DFS

想不清楚就画个树

![image-20230111223540356](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230111223540356.png)

####   排列数字

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N];

void dfs(int u, int state)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", path[i]);
        puts("");

        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!(state >> i & 1))
        {
            path[u] = i + 1;
            dfs(u + 1, state + (1 << i));
        }
}

int main()
{
    scanf("%d", &n);

    dfs(0, 0);

    return 0;
}
```

#### n-皇后

```c++
#include <iostream>

using namespace std;

const int N = 20;

int n;
char g[N][N];
bool col[N], dg[N], udg[N];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts("");
        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}
```

### BFS

![image-20230114201907642](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230114201907642.png)

适用迷宫问题并且是每条路的权重是一样的

```C++
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;
int dx[4]={-1,0,1,0}, dy[4]={0,1,0,-1};
int g[N][N], d[N][N];

int bfs(){
    memset(d, -1, sizeof d);
    queue<PII> q;
    d[0][0]=0;
    q.push({0,0});
    while(!q.empty()){
        PII top = q.front();
        int xx = top.first, yy = top.second;
        for(int i=0;i<4;i++){
            int xxx = xx+dx[i],yyy=yy+dy[i];
            if (xxx >= 0 && xxx < n && yyy >= 0 && yyy < m && g[xxx][yyy] == 0 && d[xxx][yyy] == -1)
            {
                d[xxx][yyy] = d[top.first][top.second] + 1;
                q.push({xxx, yyy});
            }
        }
        q.pop();
    }
    cout<<d[n-1][m-1];
}

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>g[i][j];
        }
    }
    bfs();
    
    return 0;
}
```

#### 八数独

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

int bfs(string state)
{
    queue<string> q;
    unordered_map<string, int> d;

    q.push(state);
    d[state] = 0;

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    string end = "12345678x";
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t == end) return d[t];

        int distance = d[t];
        int k = t.find('x');
        int x = k / 3, y = k % 3;
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);
                if (!d.count(t))
                {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[a * 3 + b], t[k]);
            }
        }
    }

    return -1;
}

int main()
{
    char s[2];

    string state;
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }

    cout << bfs(state) << endl;

    return 0;
}
```

### 树和图的遍历（深搜）

![image-20230115194712406](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230115194712406.png)

添加边

![image-20230115195038023](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230115195038023.png)

![image-20230115195739422](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230115195739422.png)

**树有n个点的话，就有n-1条边！**

![image-20230118153924587](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230118153924587.png)

![image-20230118153931937](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230118153931937.png)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = N * 2;

int n;
int h[N], e[M], ne[M], idx;
int ans = N;
bool st[N];

void add(int a, int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}

int dfs(int u)// 返回这个节点最大的子树的节点数量
{
    // 来过吗
    st[u] = true;
    
    int size = 0, sum = 0;
    // 邻接表
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        // 来过就接着走
        if (st[j]) continue;

    
        int s = dfs(j);// 返回这个节点最大的子树的节点数量
        size = max(size, s);
        // 把除了上游的子树全部加到一起，方便后面n-sum-1
        // 也可以理解成这个节点所有子树的节点加起来
        sum += s;
    }

    size = max(size, n - sum - 1);
    ans = min(ans, size);

    return sum + 1;
}

int main()
{
    scanf("%d", &n);

    memset(h, -1, sizeof h);

    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    dfs(1);

    printf("%d\n", ans);

    return 0;
}
```

### 树和图的遍历（宽搜）

![image-20230118155947885](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230118155947885.png)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int bfs()
{
    memset(d, -1, sizeof d);

    queue<int> q;
    d[1] = 0;
    q.push(1);

    while (q.size())
    {
        int t = q.front();
        q.pop();

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (d[j] == -1)
            {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }

    return d[n];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    cout << bfs() << endl;

    return 0;
}
```

### 有向图的拓扑序列

![image-20230118162226035](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230118162226035.png)

![image-20230118162240146](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230118162240146.png)

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];
int q[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool topsort()
{
    int hh = 0, tt = -1;

    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    return tt == n - 1;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);

        d[b] ++ ;
    }

    if (!topsort()) puts("-1");
    else
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
        puts("");
    }

    return 0;
}

```

### dijkstra求最短路

朴素版

n*n

![image-20230127161137619](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230127161137619.png)

```java
#include<iostream>
#include<cstring>
#include<algorithm>
#define N 510
using namespace std;

int m,n;
int g[N][N];// 邻接矩阵
int dist[N];// 每个点到第一个点的距离
bool st[N];// 这个点是否已经确定是最小值了

int dijkstra(){
    // 初始化
       memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
        // 当前的点没有确定最小值 ！st[j]
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ ) // 确定t的最小值之后，更新每个点到第一个点的距离
            //           min（j到第一个点的距离，途径t点j到第一个点的距离）
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        
        // t的最小值确定了
        st[t] = true;
    }

    // 如果是正无穷的话，就返回-1
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);

        g[a][b] = min(g[a][b], c);
    }

    printf("%d\n", dijkstra());

    return 0;
}
```

#### 堆优化

mlog(n)

![image-20230127201415067](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230127201415067.png)

堆优化不需要手写堆

![image-20230127210339781](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230127210339781.png)

```c++
// 堆优化地杰斯特拉算法 用队列实现
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define N 510

using namespace std;
typedef Pair<int, int> PII;

int n,m;
int dist[N];
int h[N],ne[N],e[N],w[N*N],idx;
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});
    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];

}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    cout << dijkstra() << endl;

    return 0;
}
```

### Bellman-Ford算法

有负权回路的话，最小路不一定有

![image-20230201192612226](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230201192612226.png)

spfa优于Bellman，但是如果限制路的条数，只能用spfa做

![image-20230201193212550](https://typora-38282696.oss-cn-shanghai.aliyuncs.com/undefinedimage-20230201193212550.png)

```c++
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 510;
const int M=10010;

struct Edge{
    int a,b,c;
}edges[M];

int dist[N],last[N];
int n,m,k;

int bellman_ford(){
    memset(dist, 0x3f, sizeof dist);
    dist[1]=0;
    
    for (int i = 0; i < k; i ++ )
    {
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++ )
        {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], last[e.a] + e.c);
        }
    }
}

int main(){
    cin>>n>>m>>k;
    
    for(int i=0;i<m;i++){
        int x,y,z;
        scanf("%d%d%d", &x,&y,&z);
        edges[i]={x,y,z};
    }
    
    bellman_ford();
    
    if(dist[n] > 0x3f3f3f3f / 2){
        puts("impossible");
    }else{
        cout<<dist[n]<<endl;
    }
}
```













## 数学知识

## 动态规划

## 贪心